package game;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
//A térképet reprezentáló osztály.
//A szkeletonban nem használjuk, mivel a futás során kérjük be a felhasználótól
//a térképen található fieldeket és itemeket.
public class Map {
	//A térképen található mezõk listája.
	protected ArrayList<Field> fields = new ArrayList<Field>();
	//A térképen található munkások listája.
	protected ArrayList<Worker> workers = new ArrayList<Worker>();
	
	//Mezõt adunk hozzá a térképhez.
	public void addField(Field f) {
		fields.add(f);
	}
	//Munkást adunk hozzá a térképhez.
	public void addWorker(Worker w) {
		workers.add(w);
	}

	//Egy kétállapotú enum:
	// - mozgásra készen áll a játékos
	// - mozgás közben van a játékos
	public enum State {
		READY_TO_MOVE,
		MOVE
	}

	//Itt találhatók azok a publikus statikus változók, amelyek a parancssor kezeléséhez szükségesek.

	//Input streamek a parancssorból való sorok beolvasásához.
	public static InputStreamReader isr = new InputStreamReader(System.in);
	public static BufferedReader reader = new BufferedReader(isr);

	//Irány és távolság. A felhasználónak szánt információ, hogy legyen elképzelése a mozgásról.
	//Megtudhatja, hogy merre mozog a munkás, illetve, hogy milyen irányba.
	public static Direction DIR = null;
	public static int DIST = 0;

	//Az éppen feldolgozott utasítást mentjük el mindig ebbe a változóba.
	public static String command = "";
	//Ebben a string tömbben szóközök mentén feldarabolva találhatjuk meg a kiadott parancsot.
	public static String[] cmd = null;

	//A munkás, akit a szkeleton során irányítunk.
	public static Worker worker = new Worker();

	//Ezt a függvényt használjuk az összes osztályban, ahol a parancssorból utasítást kérünk be.
	public static String[] getcommand() throws IOException {
		command = reader.readLine();
		cmd = command.split(" ");
		return cmd;
	}
	//A Main osztály main függvénye, az IOException a beolvasás miatt kell.
	public static void main(String[] args) throws IOException {

		//Boolean érték, azt jelzi, hogy fut-e a programunk, alapértelmezetten igen.
		boolean running = true;
		//Az alapértelmezett állapot szerint a munkás készen áll a mozgásra.
		Main.State state = Main.State.READY_TO_MOVE;

		//A játék elején írjuk ki, tájékoztatjuk a felhasználót.
		System.out.println("@@@ A játék elkezdõdött!");

		//Egy ciklus, addig fut, amíg  a játék befejezõdik.
		while(running) {
			//A munkás ekkor mozoghat vagy kiléphet
			if(state == Main.State.READY_TO_MOVE) {
				//A vizsgált távolság kezdetben 0, tehát a worker mezõjén állunk a vizsgálattal
				DIST = 0;
				//Információs üzenetek
				System.out.println("@@@ Mozoghatsz, befejezheted a játékot, vagy kiléphetsz.");
				System.out.println("@@@ Segítség: move [direction] {right, left, up, down}, exit, end.");
				//Parancsbekérés
				getcommand();
				//move parancs esetén a megadott irányba mozgunk
				//Az irányt úgy kapjuk, hogy a parancs második szavát nagybetûsítjük, majd enum
				//típusúvá konvertáljuk a valueOf() függvénnyel.
				if(cmd[0].equals("move")) {
					DIR = Direction.valueOf(cmd[1].toUpperCase());
					state = Main.State.MOVE;
				}
				//exit vagy end esetén kilépünk ciklusból
				else if(cmd[0].equals("exit") || cmd[0].equals("end") ) {
					System.out.println("@@@ A játék véget ért. Köszönöm, hogy kirpóbáltad a szkeletont!");
					running = false;
				}
			}
			//Ha mozgás közben vagyunk, akkor ez a feltételes ág fut le.
			//A mozgás parancs kiadása után kerülünk ide.
			//A munkást mozgatjuk a megadott irányba.
			//A mozgás lefutása után ismét készen állunk az új mozgásra.
			else if(state == Main.State.MOVE) {
				worker.Move(DIR);
				state = Main.State.READY_TO_MOVE;
			}
		}
	}
}
